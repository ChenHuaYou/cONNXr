//this file was generated by ../../../../../../scripts/onnx_generator/OperatorTemplate.py
#include "operator__ai_onnx__add__7.h"
#include "tracing.h"
#include "trace.h"
#include "utils.h"

operator_status
execute_operator__ai_onnx__add__7(
    Onnx__NodeProto *ctx
)
{
    TRACE_ENTRY(1);

    TRACE_NODE(3, true, ctx->onnx_node);

    /* UNCOMMENT AS NEEDED */

    Onnx__TensorProto *i_A = searchInputByIndex(ctx, 0);
    Onnx__TensorProto *i_B = searchInputByIndex(ctx, 1);

    // TRACE_TENSOR(2, true, i_A);
    // TRACE_TENSOR(2, true, i_B);

    // context_operator__ai_onnx__add__7 *op_ctx = ctx->executer_context;

    

    

    Onnx__TensorProto *o_C = searchOutputByIndex(ctx, 0);

    // TRACE_TENSOR(2, true, o_C);

    /* DO CALCULATION HERE */

    tensorAdd(float, o_C, i_A, i_B);
    //do{
    //    if(!tensorCheckBroadcasting(i_A,i_B)){
    //        TRACE_LEVEL0("invalid broadcasting");
    //        exit(EXIT_FAILURE);
    //    }else{
    //        int *subscript = malloc(o_C->n_dims*sizeof(int));
    //        for(int i=0; i<o_C->n_float_data; i++){
    //            tensorIdxToSubscript(o_C, subscript, i);
    //            //PRINT_1D_ARRAY(subscript, o_C->n_dims);
    //            //TRACE_LEVEL0("%d %d %d\n", i, tensorSubscriptToIdx(i_A,subscript),tensorSubscriptToIdx(i_B,subscript));
    //            o_C->float_data[i] = i_A->float_data[tensorSubscriptToIdx(i_A,subscript)]
    //                + i_B->float_data[tensorSubscriptToIdx(i_B,subscript)];
    //        }
    //        free(subscript);
    //    }
    //}while(0)


    TRACE_EXIT(0);

    /* CHANGE RETURN CODE IF THIS EXECUTER IS VALID */
    return OP_ENOSYS;
    // return OP_OK;
}
